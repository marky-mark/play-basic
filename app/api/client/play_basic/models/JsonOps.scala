//
// This is generated code. Do not edit this file.
//

package api.client.play_basic.models

import api.client.play_basic.tags._

import play.api.data.validation.ValidationError
import play.api.libs.json._
import play.api.libs.functional.syntax._

import scala.util.control.Exception.nonFatalCatch

object JsonOps {

  import _root_.api.common.Id._

  implicit val jodaDateTimeReads = Reads[org.joda.time.DateTime] {
    _.validate[String].flatMap { dateStr =>
      nonFatalCatch.either(new org.joda.time.DateTime(dateStr)).fold(
        ex => JsError(Seq(JsPath() -> Seq(ValidationError(ex.getMessage)))),
        JsSuccess(_)
      )
    }
  }

  

  
  implicit val formatInfo: Format[Info] = (
    (__ \ "id").formatNullable[ids.InfoId] and
    (__ \ "name").format[String] and
    (__ \ "data").format[play.api.libs.json.JsObject] and
    (__ \ "meta").format[Seq[String]]
  )(Info.apply, unlift(Info.unapply))
        

  implicit val formatProblem: Format[Problem] = (
    (__ \ "title").format[String] and
    (__ \ "status").format[Int] and
    (__ \ "detail").format[String] and
    (__ \ "tracking_id").formatNullable[ids.TrackingId]
  )(Problem.apply, unlift(Problem.unapply))
        

  private def createEnumFormat[T <: NamedEnum](fn: String => Either[EnumError, T]): Format[T] = {
    new Format[T] {
      override def reads(json: JsValue): JsResult[T] = {
        json.validate[String].flatMap { x =>
          fn(x).fold(
            error => JsError(Seq(JsPath() -> Seq(ValidationError(error.message)))),
            value => JsSuccess(value)
          )
        }
      }

      override def writes(o: T): JsValue = JsString(o.name)
    }
  }

  private def ammending[T](key: String, value: T)(implicit tjs: Writes[T]): JsValue => JsValue = _ match {
    case obj: JsObject => obj + (key -> Json.toJson(value))
    case jsValue => jsValue
  }

}


     
